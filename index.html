<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>PDF 表单填写（A路线）</title>

  <!-- ✅ 必须引入 viewer 的 css，否则表单控件位置/样式可能异常 -->
  <link rel="stylesheet" href="./pdf_viewer.css">

  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "PingFang SC", "Microsoft YaHei", Arial; margin: 16px; }
    h1 { font-size: 18px; margin: 0 0 10px; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-bottom:10px; }
    .btn { border:0; border-radius:10px; padding:10px 12px; cursor:pointer; background:#2563eb; color:white; font-weight:600; }
    .btn.secondary { background:#e5e7eb; color:#111827; }
    .btn.warn { background:#ef4444; }
    .muted { color:#6b7280; font-size:12px; margin-top:8px; }
    .badge { padding:4px 8px; border-radius:999px; background:#111827; color:white; font-size:12px; }

    #stage { position: relative; display: inline-block; border: 1px solid #e5e7eb; border-radius: 12px; padding: 8px; }
    #pdfCanvas { display:block; border-radius: 8px; }

    /* ✅ annotation layer 的容器（注意 stage padding=8，所以 left/top 也要 8） */
    #annHost { position:absolute; left:8px; top:8px; width:0; height:0; }

    /* 让表单控件看起来更像“写在PDF上”，不那么像网页输入框 */
    #annHost .annotationLayer input,
    #annHost .annotationLayer textarea,
    #annHost .annotationLayer select {
      background: transparent !important;
      border: none !important;
      outline: none !important;
      box-shadow: none !important;
      padding: 0 !important;
      margin: 0 !important;
      font-size: 14px;
    }
    #annHost .annotationLayer input:focus,
    #annHost .annotationLayer textarea:focus,
    #annHost .annotationLayer select:focus {
      outline: 1px dashed #60a5fa !important;
      border-radius: 4px;
    }

    /* 手写签名覆盖层 */
    #sigWrap { position:absolute; display:none; z-index: 20; }
    #sigCanvas { border: 1px dashed #9ca3af; border-radius: 10px; background: rgba(255,255,255,0.90); touch-action: none; }
  </style>

  <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/signature_pad@4.0.0/dist/signature_pad.umd.min.js"></script>
</head>

<body>
  <h1>PDF 表单填写（可点击输入/勾选/签名/导出）</h1>

  <div class="row">
    <button id="loadTpl" class="btn secondary">加载模板（consent_form.pdf）</button>

    <label class="row">
      <span class="btn secondary">或上传 PDF</span>
      <input type="file" id="uploadPdf" accept="application/pdf" style="display:none;">
    </label>

    <label class="row" style="gap:6px">
      <input id="flattenToggle" type="checkbox" checked />
      <span>导出时定稿（flatten，推荐打印）</span>
    </label>

    <button id="exportBtn" class="btn">生成 PDF</button>
    <button id="openBtn" class="btn secondary" disabled>打开预览</button>
    <button id="downloadBtn" class="btn secondary" disabled>下载 PDF</button>

    <span class="badge" id="status">未加载</span>
  </div>

  <div id="stage">
    <canvas id="pdfCanvas"></canvas>
    <div id="annHost"></div>

    <div id="sigWrap">
      <canvas id="sigCanvas"></canvas>
    </div>
  </div>

  <div class="row" style="margin-top:10px">
    <button id="sigClear" class="btn warn" disabled>清空手写签名</button>
    <span class="muted">更新代码后请强制刷新：Ctrl + Shift + R（GitHub Pages 常缓存旧文件）</span>
  </div>

  <div class="muted" id="tips"></div>

  <script type="module">
    import * as pdfjsLib from './pdf.mjs';
    import { AnnotationLayer } from './pdf_viewer.mjs';

    pdfjsLib.GlobalWorkerOptions.workerSrc = './pdf.worker.mjs';

    /************* 你需要改的配置（如果你的字段名不同） *************/
    const CONFIG = {
      templatePdf: 'consent_form.pdf',

      // ✅ 这里必须是你在 LibreOffice 里给“签名字段”设置的 Name
      // 如果你不是叫 Signature，就改成你实际的字段名（比如 "Signature:" 或 "签名"）
      signatureFieldName: 'Signature',
    };

    /************* 状态 *************/
    let originalPdfBytes = null;
    let pdfDocProxy = null;
    let pageProxy = null;
    let viewport = null;
    const scale = 1.5;

    let generatedBlobUrl = null;

    let sigPad = null;
    const pdfCanvas = document.getElementById('pdfCanvas');
    const annHost = document.getElementById('annHost');
    const statusEl = document.getElementById('status');
    const tipsEl = document.getElementById('tips');

    const sigWrap = document.getElementById('sigWrap');
    const sigCanvas = document.getElementById('sigCanvas');
    const sigClearBtn = document.getElementById('sigClear');

    const exportBtn = document.getElementById('exportBtn');
    const openBtn = document.getElementById('openBtn');
    const downloadBtn = document.getElementById('downloadBtn');

    function setStatus(t){ statusEl.textContent = t; }
    function setTips(t){ tipsEl.textContent = t; }

    function revokeBlobUrl(){
      if (generatedBlobUrl){
        URL.revokeObjectURL(generatedBlobUrl);
        generatedBlobUrl = null;
      }
      openBtn.disabled = true;
      downloadBtn.disabled = true;
    }

    function setGenerated(blob){
      revokeBlobUrl();
      if (!blob) return;
      generatedBlobUrl = URL.createObjectURL(blob);
      openBtn.disabled = false;
      downloadBtn.disabled = false;
    }

    document.getElementById('loadTpl').addEventListener('click', async ()=>{
      const res = await fetch(CONFIG.templatePdf);
      if (!res.ok){
        alert(`找不到 ${CONFIG.templatePdf}。请确认它在仓库根目录且文件名大小写一致。`);
        return;
      }
      originalPdfBytes = await res.arrayBuffer();
      await renderPreview(originalPdfBytes);
    });

    document.getElementById('uploadPdf').addEventListener('change', async (e)=>{
      const file = e.target.files?.[0];
      if (!file) return;
      originalPdfBytes = await file.arrayBuffer();
      await renderPreview(originalPdfBytes);
    });

    async function renderPreview(bytes){
      setStatus('加载中...');
      setTips('');
      revokeBlobUrl();

      const docParams = { data: bytes };
      if (pdfjsLib.AnnotationMode?.ENABLE_FORMS !== undefined){
        docParams.annotationMode = pdfjsLib.AnnotationMode.ENABLE_FORMS;
      }
      const loadingTask = pdfjsLib.getDocument(docParams);
      pdfDocProxy = await loadingTask.promise;

      pageProxy = await pdfDocProxy.getPage(1);
      viewport = pageProxy.getViewport({ scale });

      // canvas
      const ctx = pdfCanvas.getContext('2d');
      pdfCanvas.width = viewport.width;
      pdfCanvas.height = viewport.height;

      // annotation host
      annHost.style.width = viewport.width + 'px';
      annHost.style.height = viewport.height + 'px';
      annHost.innerHTML = '';

      // 1) render page
      const renderParams = { canvasContext: ctx, viewport };
      if (pdfjsLib.AnnotationMode?.ENABLE_FORMS !== undefined){
        renderParams.annotationMode = pdfjsLib.AnnotationMode.ENABLE_FORMS;
      }
      await pageProxy.render(renderParams).promise;

      // 2) render annotation/form layer
      await renderAnnotationLayer();

      // 3) signature overlay
      setupSignatureOverlay();

      // ✅ 调试：打印出所有字段 name（用来核对你的 "First Name" / "Yes" 等字段名是否对）
      const domFields = [...annHost.querySelectorAll('input, textarea, select')]
        .map(e => ({ name: e.name, type: e.type, tag: e.tagName }));
      console.log('表单字段（DOM）:', domFields);

      if (domFields.length === 0){
        setTips('⚠️ 没检测到任何表单字段。请确认你导出 PDF 时勾选了“创建 PDF 表单”，并且你的 PDF 确实包含表单控件。');
      } else {
        setTips(`✅ 已检测到 ${domFields.length} 个表单字段（字段名请看 Console）。`);
      }

      setStatus('已加载（可填写）');
    }

    async function renderAnnotationLayer(){
      const annotations = await pageProxy.getAnnotations({ intent: 'display' });

      const layerDiv = document.createElement('div');
      layerDiv.className = 'annotationLayer';
      annHost.appendChild(layerDiv);

      // ✅ 注意：AnnotationLayer 来自 pdf_viewer.mjs
      AnnotationLayer.render({
        viewport: viewport.clone({ dontFlip: true }),
        div: layerDiv,
        annotations,
        page: pageProxy,
        renderForms: true,
      });
    }

    function findFieldElByName(name){
      if (!name) return null;
      return annHost.querySelector(`[name="${CSS.escape(name)}"]`);
    }

    function setupSignatureOverlay(){
      sigWrap.style.display = 'none';
      sigClearBtn.disabled = true;
      sigPad = null;

      const target = findFieldElByName(CONFIG.signatureFieldName);
      if (!target){
        setTips(prev => prev);
        console.warn('未找到签名字段（DOM）:', CONFIG.signatureFieldName);
        return;
      }

      const stageRect = document.getElementById('stage').getBoundingClientRect();
      const rect = target.getBoundingClientRect();

      const left = rect.left - stageRect.left;
      const top = rect.top - stageRect.top;
      const width = rect.width;
      const height = rect.height;

      // 隐藏原签名字段（避免输入文字）
      target.style.opacity = '0';
      target.style.pointerEvents = 'none';

      sigWrap.style.display = 'block';
      sigWrap.style.left = left + 'px';
      sigWrap.style.top = top + 'px';

      const ratio = Math.max(1, Math.floor(window.devicePixelRatio || 1));
      sigCanvas.style.width = Math.max(80, width) + 'px';
      sigCanvas.style.height = Math.max(40, height) + 'px';
      sigCanvas.width = Math.max(80, Math.floor(width)) * ratio;
      sigCanvas.height = Math.max(40, Math.floor(height)) * ratio;

      const c = sigCanvas.getContext('2d');
      c.setTransform(ratio, 0, 0, ratio, 0, 0);

      sigPad = new SignaturePad(sigCanvas, { backgroundColor: 'rgba(255,255,255,0)' });
      sigClearBtn.disabled = false;
    }

    sigClearBtn.addEventListener('click', ()=>{
      if (sigPad) sigPad.clear();
    });

    function collectDomValues(){
      const els = annHost.querySelectorAll('input, textarea, select');
      const out = [];
      els.forEach(el=>{
        const name = el.name || el.getAttribute('name') || '';
        if (!name) return;
        const tag = el.tagName.toLowerCase();
        const type = (el.getAttribute('type') || '').toLowerCase();

        if (tag === 'input' && type === 'checkbox'){
          out.push({ name, kind:'checkbox', value: !!el.checked });
        } else if (tag === 'input' && (type === 'radio')){
          // radio: 只收集选中的那个
          if (el.checked) out.push({ name, kind:'radio', value: el.value || 'On' });
        } else {
          out.push({ name, kind:'text', value: el.value || '' });
        }
      });
      return out;
    }

    exportBtn.addEventListener('click', async ()=>{
      if (!originalPdfBytes){
        alert('请先加载模板或上传 PDF。');
        return;
      }

      setStatus('生成中...');
      revokeBlobUrl();

      const pdfDoc = await PDFLib.PDFDocument.load(originalPdfBytes);
      const form = pdfDoc.getForm();

      // 1) 写回所有字段（按字段名）
      const values = collectDomValues();
      for (const item of values){
        try{
          if (item.kind === 'checkbox'){
            const cb = form.getCheckBox(item.name);
            item.value ? cb.check() : cb.uncheck();
          } else if (item.kind === 'radio'){
            const rg = form.getRadioGroup(item.name);
            rg.select(item.value);
          } else {
            const tf = form.getTextField(item.name);
            tf.setText(String(item.value ?? ''));
          }
        } catch(e){
          console.warn('写入字段失败（可能字段类型不是 text/checkbox/radio 或字段名不一致）:', item.name, e);
        }
      }

      // 2) 嵌入手写签名：画到签名字段所在矩形
      if (sigPad && !sigPad.isEmpty()){
        try{
          const pngDataUrl = sigPad.toDataURL('image/png');
          const png = await pdfDoc.embedPng(pngDataUrl);

          const field = form.getField(CONFIG.signatureFieldName);
          const widgets = field.acroField.getWidgets();
          if (widgets.length){
            const w = widgets[0];
            const rect = w.getRectangle();
            const page = w.getPage();
            page.drawImage(png, { x: rect.x, y: rect.y, width: rect.width, height: rect.height });
          }
        } catch(e){
          console.warn('签名嵌入失败（多半是签名字段名不对）:', e);
          alert('手写签名嵌入失败：请检查签名字段 Name 是否与 CONFIG.signatureFieldName 一致。');
        }
      }

      // 3) 可选：定稿 flatten（打印/提交最推荐）
      if (document.getElementById('flattenToggle').checked){
        try{ form.flatten(); } catch(e){ console.warn('flatten 失败：', e); }
      }

      const outBytes = await pdfDoc.save();
      setGenerated(new Blob([outBytes], { type:'application/pdf' }));
      setStatus('已生成');
      alert('已生成 PDF。手机端建议点“打开预览”后再分享/打印。');
    });

    openBtn.addEventListener('click', ()=>{
      if (!generatedBlobUrl) return;
      window.open(generatedBlobUrl, '_blank', 'noopener');
    });

    downloadBtn.addEventListener('click', ()=>{
      if (!generatedBlobUrl) return;
      const a = document.createElement('a');
      a.href = generatedBlobUrl;
      a.download = 'Filled.pdf';
      document.body.appendChild(a);
      a.click();
      a.remove();
    });

    // 自动加载模板（如果存在）
    try{
      const r = await fetch(CONFIG.templatePdf);
      if (r.ok){
        originalPdfBytes = await r.arrayBuffer();
        await renderPreview(originalPdfBytes);
      } else {
        setStatus('未找到模板');
      }
    } catch {
      setStatus('未加载');
    }
  </script>
</body>
</html>
